// src/lib/malwareScan.ts
import crypto from "crypto";
import { GetObjectCommand } from "@aws-sdk/client-s3";
import { r2Client } from "@/lib/r2";
import { detectFileFamily } from "@/lib/fileFamily";

type HashResult = { sha256: string; sizeBytes: number; bytes: Buffer };

function asAsyncByteIterable(body: unknown): AsyncIterable<Uint8Array> {
  if (
    body &&
    typeof body === "object" &&
    Symbol.asyncIterator in body &&
    typeof (body as { [Symbol.asyncIterator]?: unknown })[Symbol.asyncIterator] === "function"
  ) {
    return body as AsyncIterable<Uint8Array>;
  }
  throw new Error("INVALID_R2_STREAM_BODY");
}

async function streamToBufferAndSha256(body: unknown, maxBytes: number): Promise<HashResult> {
  const hash = crypto.createHash("sha256");
  let size = 0;
  const chunks: Buffer[] = [];

  // body is a ReadableStream (Node.js Readable)
  for await (const chunk of asAsyncByteIterable(body)) {
    size += chunk.length;
    if (size > maxBytes) {
      throw new Error("FILE_TOO_LARGE_FOR_SCAN");
    }
    const b = Buffer.from(chunk);
    hash.update(b);
    chunks.push(b);
  }

  return { sha256: hash.digest("hex"), sizeBytes: size, bytes: Buffer.concat(chunks) };
}

export type MalwareScanVerdict = {
  ok: true;
  sha256: string;
  verdict: "clean" | "infected" | "unknown";
  riskLevel: "low" | "medium" | "high";
  flags: string[];
  meta?: Record<string, unknown>;
};

async function scanViaExternalClam(opts: {
  bytes: Buffer;
  sha256: string;
  sizeBytes: number;
  key: string;
  fileFamily: string;
}): Promise<MalwareScanVerdict> {
  const scannerUrl = (process.env.MALWARE_SCANNER_URL || "").trim();
  const scannerToken = (process.env.MALWARE_SCANNER_AUTH_TOKEN || "").trim();
  const timeoutMs = Math.max(1000, Number(process.env.MALWARE_SCANNER_TIMEOUT_MS || 20000));
  const strict = /^(1|true|yes)$/i.test(String(process.env.MALWARE_SCANNER_STRICT || "").trim());

  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort("scanner_timeout"), timeoutMs);
  try {
    const headers: Record<string, string> = {
      "content-type": "application/octet-stream",
      "x-file-sha256": opts.sha256,
      "x-file-size": String(opts.sizeBytes),
      "x-file-key": opts.key,
      "x-file-family": opts.fileFamily,
    };
    if (scannerToken) headers.authorization = `Bearer ${scannerToken}`;

    const res = await fetch(scannerUrl, {
      method: "POST",
      headers,
      body: new Uint8Array(opts.bytes),
      cache: "no-store",
      signal: controller.signal,
    });

    const payload = (await res.json().catch(() => null)) as
      | {
          verdict?: "clean" | "infected" | "unknown";
          flags?: string[];
          riskLevel?: "low" | "medium" | "high";
          signature?: string | null;
          scannerVersion?: string | null;
          meta?: unknown;
        }
      | null;

    if (!res.ok) {
      return {
        ok: true,
        sha256: opts.sha256,
        verdict: strict ? "infected" : "unknown",
        riskLevel: strict ? "high" : "medium",
        flags: [`clam:http:${res.status}`, strict ? "clam:strict_block" : "clam:error", `size:${opts.sizeBytes}`],
        meta: { source: "clam-http", status: res.status, body: payload, strict },
      };
    }

    const verdict = payload?.verdict === "infected" || payload?.verdict === "clean" ? payload.verdict : "unknown";
    const archiveDeepScanRequired = /^(1|true|yes)$/i.test(
      String(process.env.MALWARE_SCANNER_REQUIRE_ARCHIVE_DEEP_SCAN || "1").trim()
    );
    const archiveScanned =
      payload?.meta && typeof payload.meta === "object"
        ? Boolean((payload.meta as Record<string, unknown>).archiveScanned)
        : false;
    const archiveDeepScanUnverified =
      opts.fileFamily === "archive" && archiveDeepScanRequired && verdict === "clean" && !archiveScanned;

    const finalVerdict = archiveDeepScanUnverified ? "unknown" : verdict;
    const riskLevel =
      payload?.riskLevel === "high" || payload?.riskLevel === "medium" || payload?.riskLevel === "low"
        ? payload.riskLevel
        : finalVerdict === "infected"
        ? "high"
        : finalVerdict === "clean"
        ? "low"
        : "medium";
    const flags = Array.isArray(payload?.flags)
      ? payload.flags.map((f) => String(f)).filter(Boolean)
      : [finalVerdict === "infected" ? "clam:infected" : finalVerdict === "clean" ? "clam:clean" : "clam:unknown"];
    if (archiveDeepScanUnverified) flags.push("clam:archive_deep_scan_unverified");

    return {
      ok: true,
      sha256: opts.sha256,
      verdict: finalVerdict,
      riskLevel,
      flags: [...flags, `size:${opts.sizeBytes}`],
      meta: {
        source: "clam-http",
        scannerVersion: payload?.scannerVersion || "clam-http",
        signature: payload?.signature ?? null,
        archiveDeepScanRequired: archiveDeepScanRequired || undefined,
        archiveScanned: archiveScanned || undefined,
        raw: payload?.meta ?? null,
      },
    };
  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : String(e);
    return {
      ok: true,
      sha256: opts.sha256,
      verdict: strict ? "infected" : "unknown",
      riskLevel: strict ? "high" : "medium",
      flags: ["clam:exception", strict ? "clam:strict_block" : "clam:error", `size:${opts.sizeBytes}`],
      meta: { source: "clam-http", error: msg, strict },
    };
  } finally {
    clearTimeout(timeout);
  }
}

export async function scanR2Object(opts: {
  bucket: string;
  key: string;
  absMaxBytes: number;
}): Promise<MalwareScanVerdict> {
  const { bucket, key, absMaxBytes } = opts;

  const get = await r2Client.send(
    new GetObjectCommand({
      Bucket: bucket,
      Key: key,
    })
  );

  if (!get.Body) {
    return {
      ok: true,
      sha256: "",
      verdict: "unknown",
      riskLevel: "medium",
      flags: ["r2:get:missing_body"],
    };
  }

  const { sha256, sizeBytes, bytes } = await streamToBufferAndSha256(get.Body, absMaxBytes);
  const fileFamily = detectFileFamily({ filename: key });

  const scannerUrl = (process.env.MALWARE_SCANNER_URL || "").trim();
  if (scannerUrl) {
    return await scanViaExternalClam({ bytes, sha256, sizeBytes, key, fileFamily });
  }

  // No external scanner configured: fail-safe to unknown (serve remains blocked by clean-only invariant).
  return {
    ok: true,
    sha256,
    verdict: "unknown",
    riskLevel: "medium",
    flags: ["scanner:not_configured", `size:${sizeBytes}`],
    meta: { source: "none", sizeBytes },
  };
}
