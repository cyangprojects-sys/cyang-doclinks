// src/lib/malwareScan.ts
import crypto from "crypto";
import { GetObjectCommand } from "@aws-sdk/client-s3";
import { r2Client } from "@/lib/r2";

async function streamToBuffer(body: any, maxBytes: number): Promise<Buffer> {
  const chunks: Buffer[] = [];
  let size = 0;
  for await (const chunk of body as AsyncIterable<Uint8Array>) {
    const b = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
    size += b.length;
    if (size > maxBytes) throw new Error("FILE_TOO_LARGE_FOR_SCAN");
    chunks.push(b);
  }
  return Buffer.concat(chunks);
}

function sha256Hex(buf: Buffer): string {
  return crypto.createHash("sha256").update(buf).digest("hex");
}

type ClamScanResponse = {
  verdict?: string;
  status?: string;
  infected?: boolean;
  signature?: string | null;
  engine?: string | null;
  message?: string | null;
  [k: string]: unknown;
};

async function scanWithClamHttp(args: {
  bytes: Buffer;
  sha256: string;
  sizeBytes: number;
}): Promise<MalwareScanVerdict | null> {
  const url = (process.env.CLAMAV_SCAN_URL || "").trim();
  if (!url) return null;

  const token = (process.env.CLAMAV_SCAN_TOKEN || "").trim();
  const timeoutMs = Math.max(1_000, Number(process.env.CLAMAV_SCAN_TIMEOUT_MS || 30_000));
  const ctrl = new AbortController();
  const timer = setTimeout(() => ctrl.abort(), timeoutMs);
  try {
    const res = await fetch(url, {
      method: "POST",
      headers: {
        "content-type": "application/octet-stream",
        ...(token ? { authorization: `Bearer ${token}` } : {}),
      },
      body: new Uint8Array(args.bytes),
      cache: "no-store",
      signal: ctrl.signal,
    });

    if (!res.ok) {
      return {
        ok: true,
        sha256: args.sha256,
        verdict: "unknown",
        riskLevel: "medium",
        flags: ["clamav:error", `clamav:http:${res.status}`, `size:${args.sizeBytes}`],
        meta: { sizeBytes: args.sizeBytes },
      };
    }

    const data = (await res.json().catch(() => null)) as ClamScanResponse | null;
    const v = String(data?.verdict || data?.status || "").toLowerCase();
    const infected =
      data?.infected === true ||
      v === "infected" ||
      v === "malicious" ||
      v === "virus" ||
      v === "found";
    const clean = v === "clean" || v === "ok";

    if (infected) {
      return {
        ok: true,
        sha256: args.sha256,
        verdict: "infected",
        riskLevel: "high",
        flags: [
          "clamav:infected",
          data?.signature ? `clamav:signature:${String(data.signature)}` : "clamav:signature:unknown",
          `size:${args.sizeBytes}`,
        ],
        meta: { sizeBytes: args.sizeBytes, clamav: data },
      };
    }

    if (clean) {
      return {
        ok: true,
        sha256: args.sha256,
        verdict: "clean",
        riskLevel: "low",
        flags: ["clamav:clean", `size:${args.sizeBytes}`],
        meta: { sizeBytes: args.sizeBytes, clamav: data },
      };
    }

    return {
      ok: true,
      sha256: args.sha256,
      verdict: "unknown",
      riskLevel: "medium",
      flags: ["clamav:unknown", `size:${args.sizeBytes}`],
      meta: { sizeBytes: args.sizeBytes, clamav: data },
    };
  } catch (e: any) {
    return {
      ok: true,
      sha256: args.sha256,
      verdict: "unknown",
      riskLevel: "medium",
      flags: ["clamav:exception", `size:${args.sizeBytes}`],
      meta: { sizeBytes: args.sizeBytes, error: String(e?.message || e) },
    };
  } finally {
    clearTimeout(timer);
  }
}

export type MalwareScanVerdict = {
  ok: true;
  sha256: string;
  verdict: "clean" | "infected" | "unknown";
  riskLevel: "low" | "medium" | "high";
  flags: string[];
  meta?: any;
};

export async function scanR2Object(opts: {
  bucket: string;
  key: string;
  absMaxBytes: number;
}): Promise<MalwareScanVerdict> {
  const { bucket, key, absMaxBytes } = opts;

  const get = await r2Client.send(new GetObjectCommand({ Bucket: bucket, Key: key }));

  if (!get.Body) {
    return {
      ok: true,
      sha256: "",
      verdict: "unknown",
      riskLevel: "medium",
      flags: ["r2:get:missing_body"],
    };
  }

  const bytes = await streamToBuffer(get.Body, absMaxBytes);
  const sizeBytes = bytes.length;
  const sha256 = sha256Hex(bytes);

  // Preferred scanner path: ClamAV-compatible HTTP service.
  const clamVerdict = await scanWithClamHttp({ bytes, sha256, sizeBytes });
  if (clamVerdict) return clamVerdict;

  // Optional VirusTotal hash lookup (no upload).
  const vtKey = (process.env.VIRUSTOTAL_API_KEY || "").trim();
  if (!vtKey) {
    return {
      ok: true,
      sha256,
      verdict: "unknown",
      riskLevel: "medium",
      flags: ["vt:disabled", `size:${sizeBytes}`],
      meta: { sizeBytes },
    };
  }

  try {
    const res = await fetch(`https://www.virustotal.com/api/v3/files/${sha256}`, {
      headers: {
        "x-apikey": vtKey,
        "accept": "application/json",
      },
      // keep it short; this runs in cron
      cache: "no-store",
    });

    if (res.status === 404) {
      return {
        ok: true,
        sha256,
        verdict: "unknown",
        riskLevel: "medium",
        flags: ["vt:unknown_hash", `size:${sizeBytes}`],
        meta: { sizeBytes },
      };
    }

    if (!res.ok) {
      return {
        ok: true,
        sha256,
        verdict: "unknown",
        riskLevel: "medium",
        flags: ["vt:error", `vt:http:${res.status}`, `size:${sizeBytes}`],
        meta: { sizeBytes },
      };
    }

    const data: any = await res.json().catch(() => null);
    const stats = data?.data?.attributes?.last_analysis_stats || null;
    const malicious = Number(stats?.malicious ?? 0);
    const suspicious = Number(stats?.suspicious ?? 0);

    if (malicious > 0) {
      return {
        ok: true,
        sha256,
        verdict: "infected",
        riskLevel: "high",
        flags: ["vt:malicious", `vt:malicious:${malicious}`, `vt:suspicious:${suspicious}`, `size:${sizeBytes}`],
        meta: { sizeBytes, vt: { malicious, suspicious, stats } },
      };
    }

    if (suspicious > 0) {
      return {
        ok: true,
        sha256,
        verdict: "unknown",
        riskLevel: "medium",
        flags: ["vt:suspicious", `vt:suspicious:${suspicious}`, `size:${sizeBytes}`],
        meta: { sizeBytes, vt: { malicious, suspicious, stats } },
      };
    }

    return {
      ok: true,
      sha256,
      verdict: "clean",
      riskLevel: "low",
      flags: ["vt:clean", `size:${sizeBytes}`],
      meta: { sizeBytes, vt: { malicious, suspicious, stats } },
    };
  } catch (e: any) {
    return {
      ok: true,
      sha256,
      verdict: "unknown",
      riskLevel: "medium",
      flags: ["vt:exception", `size:${sizeBytes}`],
      meta: { sizeBytes, error: String(e?.message || e) },
    };
  }
}
