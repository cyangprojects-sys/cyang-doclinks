// src/lib/malwareScan.ts
import crypto from "crypto";
import { GetObjectCommand } from "@aws-sdk/client-s3";
import { r2Client } from "@/lib/r2";

type HashResult = { sha256: string; sizeBytes: number };

async function streamToSha256(body: any, maxBytes: number): Promise<HashResult> {
  const hash = crypto.createHash("sha256");
  let size = 0;

  // body is a ReadableStream (Node.js Readable)
  for await (const chunk of body as AsyncIterable<Uint8Array>) {
    size += chunk.length;
    if (size > maxBytes) {
      throw new Error("FILE_TOO_LARGE_FOR_SCAN");
    }
    hash.update(chunk);
  }

  return { sha256: hash.digest("hex"), sizeBytes: size };
}

export type MalwareScanVerdict = {
  ok: true;
  sha256: string;
  verdict: "clean" | "infected" | "unknown";
  riskLevel: "low" | "medium" | "high";
  flags: string[];
  meta?: any;
};

export async function scanR2Object(opts: {
  bucket: string;
  key: string;
  absMaxBytes: number;
}): Promise<MalwareScanVerdict> {
  const { bucket, key, absMaxBytes } = opts;

  const get = await r2Client.send(
    new GetObjectCommand({
      Bucket: bucket,
      Key: key,
    })
  );

  if (!get.Body) {
    return {
      ok: true,
      sha256: "",
      verdict: "unknown",
      riskLevel: "medium",
      flags: ["r2:get:missing_body"],
    };
  }

  const { sha256, sizeBytes } = await streamToSha256(get.Body, absMaxBytes);

  // Optional VirusTotal hash lookup (no upload).
  const vtKey = (process.env.VIRUSTOTAL_API_KEY || "").trim();
  if (!vtKey) {
    return {
      ok: true,
      sha256,
      verdict: "unknown",
      riskLevel: "low",
      flags: ["vt:disabled", `size:${sizeBytes}`],
      meta: { sizeBytes },
    };
  }

  try {
    const res = await fetch(`https://www.virustotal.com/api/v3/files/${sha256}`, {
      headers: {
        "x-apikey": vtKey,
        "accept": "application/json",
      },
      // keep it short; this runs in cron
      cache: "no-store",
    });

    if (res.status === 404) {
      return {
        ok: true,
        sha256,
        verdict: "unknown",
        riskLevel: "low",
        flags: ["vt:unknown_hash", `size:${sizeBytes}`],
        meta: { sizeBytes },
      };
    }

    if (!res.ok) {
      return {
        ok: true,
        sha256,
        verdict: "unknown",
        riskLevel: "medium",
        flags: ["vt:error", `vt:http:${res.status}`, `size:${sizeBytes}`],
        meta: { sizeBytes },
      };
    }

    const data: any = await res.json().catch(() => null);
    const stats = data?.data?.attributes?.last_analysis_stats || null;
    const malicious = Number(stats?.malicious ?? 0);
    const suspicious = Number(stats?.suspicious ?? 0);

    if (malicious > 0) {
      return {
        ok: true,
        sha256,
        verdict: "infected",
        riskLevel: "high",
        flags: ["vt:malicious", `vt:malicious:${malicious}`, `vt:suspicious:${suspicious}`, `size:${sizeBytes}`],
        meta: { sizeBytes, vt: { malicious, suspicious, stats } },
      };
    }

    if (suspicious > 0) {
      return {
        ok: true,
        sha256,
        verdict: "unknown",
        riskLevel: "medium",
        flags: ["vt:suspicious", `vt:suspicious:${suspicious}`, `size:${sizeBytes}`],
        meta: { sizeBytes, vt: { malicious, suspicious, stats } },
      };
    }

    return {
      ok: true,
      sha256,
      verdict: "clean",
      riskLevel: "low",
      flags: ["vt:clean", `size:${sizeBytes}`],
      meta: { sizeBytes, vt: { malicious, suspicious, stats } },
    };
  } catch (e: any) {
    return {
      ok: true,
      sha256,
      verdict: "unknown",
      riskLevel: "medium",
      flags: ["vt:exception", `size:${sizeBytes}`],
      meta: { sizeBytes, error: String(e?.message || e) },
    };
  }
}
