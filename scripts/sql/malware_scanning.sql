-- scripts/sql/malware_scanning.sql
--
-- Async malware scanning primitives: queue + results storage + auto-quarantine trigger.
--
-- Adds:
--  - public.malware_scan_jobs
--  - docs fields for scan workflow (scan_status already exists)
--  - DB trigger: risk_level='high' -> moderation_status='quarantined'
--
-- Safe to run multiple times.

create table if not exists public.malware_scan_jobs (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),

  doc_id uuid not null references public.docs(id) on delete cascade,
  r2_bucket text not null,
  r2_key text not null,

  status text not null default 'queued', -- queued|running|clean|infected|error|skipped
  attempts int not null default 0,

  started_at timestamptz null,
  finished_at timestamptz null,

  sha256 text null,
  scanner_version text null,

  last_error text null,
  result jsonb null
);

create unique index if not exists malware_scan_jobs_doc_id_uq on public.malware_scan_jobs (doc_id);
create index if not exists malware_scan_jobs_status_idx on public.malware_scan_jobs (status, created_at);
create index if not exists malware_scan_jobs_created_at_idx on public.malware_scan_jobs (created_at desc);

-- Optional: track a "pending"/"running" scan_status value even if earlier scripts didn't mention it.
-- No schema change needed for docs.scan_status (text).

-- Auto-quarantine trigger: whenever risk_level is set to 'high', force moderation_status to 'quarantined'
do $$
begin
  -- create trigger function if missing
  if not exists (
    select 1 from pg_proc where proname = 'docs_auto_quarantine_high_risk'
  ) then
    execute $fn$
      create function public.docs_auto_quarantine_high_risk()
      returns trigger
      language plpgsql
      as $$
      begin
        -- If doc becomes high-risk, quarantine it until reviewed.
        if (new.risk_level is not null) and lower(new.risk_level::text) = 'high' then
          if (new.moderation_status is null) or lower(new.moderation_status::text) not in ('deleted') then
            new.moderation_status := 'quarantined';
          end if;

          -- Keep scan_status consistent if caller didn't set it.
          if new.scan_status is null or lower(new.scan_status::text) in ('unscanned', 'clean', 'risky', 'queued', 'pending', 'running') then
            new.scan_status := 'quarantined';
          end if;
        end if;

        return new;
      end;
      $$;
    $fn$;
  end if;

  -- create trigger if missing
  if not exists (
    select 1
    from pg_trigger
    where tgname = 'trg_docs_auto_quarantine_high_risk'
  ) then
    execute $trg$
      create trigger trg_docs_auto_quarantine_high_risk
      before insert or update of risk_level, scan_status on public.docs
      for each row
      execute function public.docs_auto_quarantine_high_risk();
    $trg$;
  end if;
end $$;
